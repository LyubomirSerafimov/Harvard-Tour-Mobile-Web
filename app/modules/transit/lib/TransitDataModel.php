<?php

/*
 * Copyright Â© 2010 - 2012 Modo Labs Inc. All rights reserved.
 *
 * The license governing the contents of this file is located in the LICENSE
 * file located at the root directory of this distribution. If the LICENSE file
 * is missing, please contact sales@modolabs.com.
 *
 */

/**
  * TransitDataModel Abstract Class
  * @package Transit
  */

includePackage('Maps'); // for Polyline class

abstract class TransitDataModel extends DataModel implements TransitDataModelInterface
{
    protected $args = array();
    protected $agencyIDs = array();
    protected $routeWhitelist = array();
    protected $routeBlacklist = array();
    protected $viewAsLoopRoutes = array();
    protected $scheduleViewRoutes = array();
    protected $splitByHeadsignRoutes = array();
    protected $transitDefaultRouteColor = "b12727"; // shade of redirect
    protected $transitRouteRunningPadding = 1800; // 30 mins
    protected $transitListUpcomingBusPadding = 7200; // 2 hours
    protected $transitScheduleUpcomingBusPadding = 14400; // 4 hours
    
    protected static $routeRunningPadding = null;
    
    protected $routes    = array();
    protected $stops     = array();
    protected $overrides = array();

    // For routes where not all vehicles stop at all stops
    protected $stopOrders = array();
    
    static private $arrows = array(
        '1' => 'n',
        '2' => 'ne',
        '3' => 'e',
        '4' => 'se',
        '5' => 's',
        '6' => 'sw',
        '7' => 'w',
        '8' => 'nw',
    );
    
    static private $sortHelper = array();
    
    const GOOGLE_STATIC_MAPS_URL = 'http://maps.google.com/maps/api/staticmap?';
    const GOOGLE_CHART_API_URL = 'http://chart.apis.google.com/chart?';
    
    const LOOP_DIRECTION = 'loop';
    const LOOP_DIRECTION_NAME = '';  // Suppress name since it is redundant
    
    // Set this to true for stop order debugging
    const DLOG_STOP_ORDER = false;
    
    // These spew to the log file when it is in debug mode so turn off by default
    const DLOG_IS_RUNNING = false;
    const DLOG_ARRIVAL_TIMES = false;
    const DLOG_TRANSIT_TIME = false;
    const DLOG_STOP_GRAPH_SORT = false;
    const DLOG_MISC = false;
    
    const DLOG_ENABLE_ERROR_LOG = false;
    
    public static function dlog($message, $shouldLog=self::DLOG_MISC) {
        if ($shouldLog) {
            Kurogo::log(LOG_DEBUG, $message, 'transit');
            
            // Many of the log messages generated by the transit module are multi-line 
            // or white-space formatted in a way that errors stand out.  The Kurogo
            // logging system does not support multi-line messages and puts a very
            // large prefix string in front of every message, making the white space
            // formatting useless if you don't have a 30" monitor
            if (self::DLOG_ENABLE_ERROR_LOG) {
                error_log($message);
            }
        }
    }
    
    public static function updateCacheLifetimeForShell(&$cacheLifetime) {
        // daemons should load cached files aggressively to beat user page loads
        $cacheLifetime -= 3600;
        if ($cacheLifetime < 1) { $cacheLifetime = 1; }
    }
    
    protected function init($args) {
        parent::init($args);
        
        if (isset($args['FIELD_OVERRIDES'])) {
            $this->overrides = $args['FIELD_OVERRIDES'];
        }
        
        if (isset($args['AGENCIES'])) {
            $this->agencyIDs = array_filter(array_map('trim', explode(',', $args['AGENCIES'])));
        }
        if (!$this->agencyIDs) {
            Kurogo::log(LOG_ERR, "Agencies not specified in feeds.ini", 'transit');
        }
        
        if (isset($args['ROUTE_WHITELIST'])) {
            $this->routeWhitelist = array_filter(array_map('trim', explode(',', $args['ROUTE_WHITELIST'])));
        }
        
        if (isset($args['ROUTE_BLACKLIST'])) {
            $this->routeBlacklist = array_filter(array_map('trim', explode(',', $args['ROUTE_BLACKLIST'])));
        }
        
        if (isset($args['VIEW_ROUTES_AS_LOOP'])) {
            if ($args['VIEW_ROUTES_AS_LOOP'] === "*") {
                $this->viewAsLoopRoutes = true; // all routes
            } else {
                $this->viewAsLoopRoutes = array_filter(array_map('trim', explode(',', $args['VIEW_ROUTES_AS_LOOP'])));
            }
        }
        
        if (isset($args['SCHEDULE_VIEW'])) {
            if ($args['SCHEDULE_VIEW'] === "*") {
                $this->scheduleViewRoutes = true; // all routes
            } else {
                $this->scheduleViewRoutes = array_filter(array_map('trim', explode(',', $args['SCHEDULE_VIEW'])));
            }
        }

        if (isset($args['SPLIT_BY_HEADSIGN'])) {
            if ($args['SPLIT_BY_HEADSIGN'] === "*") {
                $this->splitByHeadsignRoutes = true; // all routes
            } else {
                $this->splitByHeadsignRoutes = array_filter(array_map('trim', explode(',', $args['SPLIT_BY_HEADSIGN'])));
            }
        }
        
        if (isset($args['TRANSIT_ROUTE_RUNNING_PADDING'])) {
            $this->transitRouteRunningPadding = $args['TRANSIT_ROUTE_RUNNING_PADDING'];
        }
        
        if (isset($args['TRANSIT_LIST_UPCOMING_BUS_PADDING'])) {
            $this->transitListUpcomingBusPadding = $args['TRANSIT_LIST_UPCOMING_BUS_PADDING'];
        }
        
        if (isset($args['TRANSIT_SCHEDULE_UPCOMING_BUS_PADDING'])) {
            $this->transitScheduleRouteRunningPadding = $args['TRANSIT_SCHEDULE_UPCOMING_BUS_PADDING'];
        }
        
        $this->loadData();
    }
    
    protected function viewRoute($routeID) {
        $passedWhitelist = count($this->routeWhitelist) === 0 || in_array($routeID, $this->routeWhitelist);
        $passedBlacklist = count($this->routeBlacklist) === 0 || !in_array($routeID, $this->routeBlacklist);
        return $passedWhitelist && $passedBlacklist;
    }
    
    protected function viewRouteAsLoop($routeID) {
        return $this->viewAsLoopRoutes === true || in_array($routeID, $this->viewAsLoopRoutes);
    }
    
    protected function viewRouteInScheduleView($routeID) {
        return $this->scheduleViewRoutes === true || in_array($routeID, $this->scheduleViewRoutes);
    }
    
    protected function viewRouteSplitByHeadsign($routeID) {
        return $this->splitByHeadsignRoutes === true || in_array($routeID, $this->splitByHeadsignRoutes);
    }
    
    protected function updatePredictionData($routeID) {
        // override if you want to break out loading of prediction data
    }
      
    public function getRouteVehicles($routeID) {
        // override if the parser has vehicle locations
        return array();
    }
    
    protected function getRouteRunningPadding() {
        return $this->transitRouteRunningPadding;
    }
    
    protected function getValidRouteSegmentTimeRangeForTimestamp($routeID, $timestamp) {
        if (!$timestamp) {
          $timestamp = TransitTime::getCurrentTime();
        }
        $segmentPadding = $this->viewRouteInScheduleView($routeID) ? 
            $this->transitScheduleUpcomingBusPadding : $this->transitListUpcomingBusPadding;
        return array($timestamp, $timestamp + $segmentPadding);
    }
    
    protected function getValidRouteRunningTimeRangeForTimestamp($routeID, $timestamp) {
        if (!$timestamp) {
          $timestamp = TransitTime::getCurrentTime();
        }
        return array($timestamp, $timestamp + $this->getRouteRunningPadding());
    }
    
    protected function setUpcomingRouteStops($routeID, &$directions, $segmentTimeRange) {
        // override if you have vehicle locations that say what stop is upcoming
        
        $time = reset($segmentTimeRange);
        $segmentPadding = end($segmentTimeRange) - reset($segmentTimeRange);
        
        foreach ($directions as $directionID => $directionInfo) {
            // Walk the stops to figure out which is upcoming
            $stopIndexes = array_keys($directionInfo['stops']);
            $firstStopIndex = reset($stopIndexes);
            $lastStopIndex = end($stopIndexes);
            
            $firstStopPrevIndex  = null;
            $lastStopNextIndex  = null;
            if (count($directions) == 1 && count($stopIndexes)) {
                // Loop case
                $firstStopPrevIndex = end($stopIndexes);
                if (self::isSameStop($directionInfo['stops'][$firstStopIndex]['id'], 
                                     $directionInfo['stops'][$firstStopPrevIndex]['id'])) {
                    $firstStopPrevIndex = prev($stopIndexes);
                }
                $lastStopNextIndex = reset($stopIndexes);
                if (self::isSameStop($directionInfo['stops'][$lastStopIndex]['id'], 
                                     $directionInfo['stops'][$lastStopNextIndex]['id'])) {
                    $lastStopNextIndex = next($stopIndexes);
                }
            }
            
            foreach ($stopIndexes as $i => $stopIndex) {
                $arrives = $directionInfo['stops'][$stopIndex]['arrives'];
                
                $prevArrives = 0; // Non-loop case
                if ($stopIndex == $firstStopIndex) {
                    if ($firstStopPrevIndex) {
                        // Loop case
                        $prevArrives = $directionInfo['stops'][$firstStopPrevIndex]['arrives'];
                    }
                } else {
                    $prevArrives = $directionInfo['stops'][$stopIndexes[$i-1]]['arrives'];
                }
                $nextArrives = 0; // Non-loop case
                if ($stopIndex == $lastStopIndex) {
                    if ($lastStopNextIndex) {
                        // Loop case
                        $nextArrives = $directionInfo['stops'][$lastStopNextIndex]['arrives'];
                    }
                } else {
                    $nextArrives = $directionInfo['stops'][$stopIndexes[$i+1]]['arrives'];
                }
                // Suppress any stops which are outside the upcoming segment padding
                $directions[$directionID]['stops'][$stopIndex]['upcoming'] = 
                    (abs($arrives - $time) < $segmentPadding) && 
                    ($arrives <= $prevArrives && $arrives < $nextArrives);
                
                self::dlog('stop '.
                    str_pad($directions[$directionID]['stops'][$stopIndex]['id'], 8, ' ', STR_PAD_RIGHT).' upcoming check: '.
                    str_pad(intval($arrives), 10, ' ', STR_PAD_RIGHT).' <= '.
                    str_pad(intval($prevArrives), 10, ' ', STR_PAD_RIGHT).' '.
                    ($arrives <= $prevArrives ? 'true ' : 'false').' // '.
                    str_pad(intval($arrives), 10, ' ', STR_PAD_RIGHT).' < '.
                    str_pad(intval($nextArrives), 10, ' ', STR_PAD_RIGHT).' '.
                    ($arrives < $nextArrives ? 'true ' : 'false').
                    ($directions[$directionID]['stops'][$stopIndex]['upcoming'] ? ' UPCOMING' : ''), self::DLOG_ARRIVAL_TIMES);
            }
        }
    }

    
    protected function getServiceId() {
        return '';
    }
  
    protected function getServiceName() {
        return '';
    }
    
    protected function getServiceLink() {
        return '';
    }
    
    public function getServiceInfoForRoute($routeID) {
        return array(
            'id'    => $this->getServiceId(),
            'title' => $this->getServiceName(),
            'url'   => $this->getServiceLink(),
        );
    }
    
    abstract protected function loadData();
    
    abstract protected function isLive();
    
    //
    // Routes
    //
    
    protected function addRoute($route) {
        $id = $route->getID();
        
        if (isset($this->routes[$id])) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): Duplicate route '$id'", 'transit');
            return;
        }
        $this->routes[$id] = $route;
    }
    
    protected function getRoute($id) {
        if (!isset($this->routes[$id])) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): No such route '$id'", 'transit');
            return false;
        }
    
        return $this->routes[$id];
    }
    
    // used to avoid warnings when looking for the right parser for a route
    public function hasRoute($routeID) {
        return isset($this->routes[$routeID]);
    }
  
    //
    // Stops
    //
  
    protected function addStop($stop) {
        $id = $stop->getID();
    
        if (isset($this->stops[$id])) {
            // This case seems to happen fairly often
            // Kurogo::log(LOG_WARNING, __FUNCTION__."(): Duplicate stop '$id'", 'transit');
            return;
        }
        $this->stops[$id] = $stop;
    }
      
    protected function getStop($id) {
        if (!isset($this->stops[$id])) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): No such stop '$id'", 'transit');
            return false;
        }
    
        return $this->stops[$id];
    }
    
    // used to avoid warnings when looking at the wrong agency
    public function hasStop($id) {
        return isset($this->stops[$id]);
    }
    
    protected function getMapIconUrlForRouteStop($routeID) {
        if ($_SERVER['SERVER_NAME'] != 'localhost') {
            return FULL_URL_PREFIX.'modules/transit/images/shuttle_stop_dot.png';
        } else {
            return self::GOOGLE_CHART_API_URL.http_build_query(array(
                'chst' => 'd_simple_text_icon_left',
                'chld' => '|9|000|glyphish_target|12|'.$this->getRouteColor($routeID).'|FFF',
            ));
        }
    }
   
    protected function getMapIconUrlForRouteStopPin($routeID=null) {
        if ($_SERVER['SERVER_NAME'] != 'localhost') {
            return FULL_URL_PREFIX.'modules/transit/images/shuttle_stop_pin.png';
        } else {
            $routeColor = $routeID ? $this->getRouteColor($routeID) : $this->transitDefaultRouteColor;
            
            return self::GOOGLE_CHART_API_URL.http_build_query(array(
                'chst' => 'd_map_pin_icon',
                'chld' => "bus|$routeColor",
            ));
        }
    }
   
    protected function getMapIconUrlForRouteVehicle($routeID, $vehicle=null) {
        // same icon for every vehicle by default
        return self::GOOGLE_CHART_API_URL.http_build_query(array(
            'chst' => 'd_map_pin_icon',
            'chld' => 'bus|'.$this->getRouteColor($routeID),
        ));
    }
   
    protected function getMapMarkersForVehicles($vehicles) {
        $query = '';
        
        if (count($vehicles)) {
            $firstVehicle = reset($vehicles);
          
            $markers = "icon:".$this->getMapIconUrlForRouteVehicle($firstVehicle['routeID']);
            foreach ($vehicles as $vehicle) {
                if ($vehicle['lat'] && $vehicle['lon']) {
                    $markers .= "|{$vehicle['lat']},{$vehicle['lon']}";
                }
            }
            $query .= '&'.http_build_query(array(
                'markers' => $markers,
            ));
        }
        
        return $query;
    }  
    
    protected function getDirectionForHeading($heading) {
        $arrowIndex = ($heading / 45) + 1.5;
        if ($arrowIndex > 8) { $arrowIndex = 8; }
        if ($arrowIndex < 0) { $arrowIndex = 0; }
        $arrowIndex = floor($arrowIndex);
        
        return self::$arrows[$arrowIndex];
    }
    
    protected function getRouteColor($routeID) {
        return $this->transitDefaultRouteColor;
    }
    
    protected function getRouteDirectionPredictionsForStop($routeID, $stopID, $timestampRange) {
        $route = $this->getRoute($routeID);
        if (!$route) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): No such route '$routeID'", 'transit');
            return false;
        }
        
        $routeDirections = $this->getRouteDirections($route, $timestampRange);
        
        $directionPredictions = array();
        foreach ($routeDirections as $directionID => $directionInfo) {
            $directionHasStop = false;
            $predictions = array();
            foreach ($directionInfo['segments'] as $segment) {
                $segmentHasStop = false;
                
                foreach ($segment->getStops() as $stopInfo) {
                    if ($stopInfo['stopID'] == $stopID) {
                        $segmentHasStop = true;
                        $directionHasStop = true;
                        break;
                    }
                }
                
                if ($segmentHasStop) {
                    $predictions = array_merge($predictions, $segment->getArrivalTimesForStop($stopID, $timestampRange));
                }
            }
            
            if ($directionHasStop) {
                if (count($predictions)) {
                    sort($predictions);
                    $predictions = array_values(array_unique($predictions, SORT_NUMERIC));
                }
    
                $directionPredictions[$directionID] = array(
                    'name'        => $directionInfo['name'],
                    'running'     => $directionInfo['running'],
                    'predictions' => $predictions,
                );
            }
        }
        
        if ($this->viewRouteSplitByHeadsign($routeID)) {
            // Headsigns are named so sort them
            uasort($directionPredictions, array(get_class(), 'sortDirections'));
            
        } else if ($this->viewRouteAsLoop($routeID)) {
            $names = array();
            $predictions = array();
            $running = false;
            
            foreach ($directionPredictions as $directionInfo) {
                $names[] = $directionInfo['name'];
                $predictions = array_merge($predictions, $directionInfo['predictions']);
                if ($directionInfo['running']) {
                    $running = true;
                }
            }
            if (count($predictions)) {
                sort($predictions);
                $predictions = array_values(array_unique($predictions, SORT_NUMERIC));
            }
            
            $directionPredictions = array(
                self::LOOP_DIRECTION => array(
                    'name'        => self::LOOP_DIRECTION_NAME,
                    'predictions' => $predictions,
                    'running'     => $running,
                ),
            );
        }
        
        return $directionPredictions;
    }

    //
    // Query functions
    // 
    
    public function getStopInfo($stopID) {
        if (!isset($this->stops[$stopID])) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): No such stop '$stopID'", 'transit');
            return array();
        }
      
        $time = TransitTime::getCurrentTime();
    
        $routePredictions = array();
        foreach ($this->routes as $routeID => $route) {
            if (!$route->hasStop($stopID)) { continue; }
            
            $runningTimeRange = $this->getValidRouteRunningTimeRangeForTimestamp($routeID, $time);
            $segmentTimeRange = $this->getValidRouteSegmentTimeRangeForTimestamp($routeID, $time);
            
            $this->updatePredictionData($route->getID());
            
            $directionPredictions = $this->getRouteDirectionPredictionsForStop($routeID, $stopID, $segmentTimeRange);
            
            $routePredictions[$routeID] = array(
                'name'       => $route->getName(),
                'agency'     => $route->getAgencyID(),
                'directions' => $directionPredictions,
                'running'    => $route->isRunning($runningTimeRange),
                'live'       => $this->isLive(),
            );
        }
        uasort($routePredictions, array(get_class(), 'sortRoutes'));
        
        $stopInfo = array(
            'name'        => $this->stops[$stopID]->getName(),
            'description' => $this->stops[$stopID]->getDescription(),
            'coordinates' => $this->stops[$stopID]->getCoordinates(),
            'stopIconURL' => $this->getMapIconUrlForRouteStopPin(),
            'routes'      => $routePredictions,
        );
        
        $this->applyStopInfoOverrides($stopID, $stopInfo);
    
        return $stopInfo;
    }
    
    public function getMapImageForStop($id, $width, $height) {
        $stop = $this->getStop($id);
        if (!$stop) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): No such stop '$id'", 'transit');
            return false;
        }
        
        $coords = $stop->getCoordinates();
        $iconURL = $this->getMapIconUrlForRouteStopPin();
        
        $query = http_build_query(array(
            'sensor'  => 'false',
            'size'    => "{$width}x{$height}",
            'markers' => "icon:$iconURL|{$coords['lat']},{$coords['lon']}",
        ));
        
        return self::GOOGLE_STATIC_MAPS_URL.$query;
    }
  
    public function getMapImageForRoute($id, $width, $height) {
        $route = $this->getRoute($id);
        if (!$route) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): No such route '$id'", 'transit');
            return false;
        }
        
        $paths = $route->getPaths();
        $color = $this->getRouteColor($id);
        
        if (!count($paths)) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): No path for route '$id'", 'transit');
            return false;
        }
        
        $query = http_build_query(array(
            'sensor' => 'false',
            'size'   => "{$width}x{$height}",
        ));
      
        $time = TransitTime::getCurrentTime();
        $runningTimeRange = $this->getValidRouteRunningTimeRangeForTimestamp($id, $time);
        
        if ($route->isRunning($runningTimeRange)) {
            $vehicles = $this->getRouteVehicles($id);
            $query .= $this->getMapMarkersForVehicles($vehicles);
        }
        
        foreach ($paths as $points) {
            foreach ($points as &$point) {
                $point = array_values($point);
            }
            $query .= '&'.http_build_query(array(
                'path' => 'weight:3|color:0x'.$color.'C0|enc:'.Polyline::encodeFromArray($points)
            ), 0, '&amp;');
        }
        
        return self::GOOGLE_STATIC_MAPS_URL.$query;
    }
  
    public function routeIsRunning($routeID, $time=null) {
        $route = $this->getRoute($routeID);
        if (!$route) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): No such route '$routeID'", 'transit');
            return false;
        }
        
        $this->updatePredictionData($routeID);

        $runningTimeRange = $this->getValidRouteRunningTimeRangeForTimestamp($routeID, $time);
        
        return $route->isRunning($runningTimeRange);
    }
    
    public function getRoutePaths($routeID) {
        $route = $this->getRoute($routeID);
        if (!$route) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): No such route '$routeID'", 'transit');
            return array();
        }
    
        return $route->getPaths();
    }
    
    public function getRouteInfo($routeID, $time=null) {
        $route = $this->getRoute($routeID);
        if (!$route) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): No such route '$routeID'", 'transit');
            return array();
        }
        $this->updatePredictionData($routeID);
        
        $runningTimeRange = $this->getValidRouteRunningTimeRangeForTimestamp($routeID, $time);
        $segmentTimeRange = $this->getValidRouteSegmentTimeRangeForTimestamp($routeID, $time);
        
        $inService = false;
        $isRunning = $route->isRunning($runningTimeRange, $inService);
        
        $routeInfo = array(
            'agency'          => $route->getAgencyID(),
            'name'            => $route->getName(),
            'description'     => $route->getDescription(),
            'color'           => $this->getRouteColor($routeID),
            'live'            => $isRunning ? $this->isLive() : false,
            'frequency'       => round($route->getServiceFrequency($segmentTimeRange) / 60, 0),
            'running'         => $isRunning,
            'inService'       => $inService,
            'stopIconURL'     => $this->getMapIconUrlForRouteStop($routeID),
            'vehicleIconURL'  => $this->getMapIconUrlForRouteVehicle($routeID),
            'view'            => $this->viewRouteInScheduleView($routeID) ? 'schedule' : 'list',
            'splitByHeadsign' => $this->viewRouteSplitByHeadsign($routeID),
            'directions'      => array(),
        );
        
        $routeDirections = $this->getRouteDirections($route, $runningTimeRange);
        self::dlog('routeDirectionIDs: '.implode(', ', array_keys($routeDirections)));
        
        foreach ($routeDirections as $directionID => $directionInfo) {
            self::dlog("HEADSIGN: {$directionInfo['name']}", self::DLOG_STOP_GRAPH_SORT);
            
            // Get formatted direction information
            $routeInfo['directions'][$directionID] = $this->getDirectionInfo(
                $routeID, $directionInfo['name'], $directionInfo['segments'], $directionInfo['stopOrder'], $segmentTimeRange);
            $routeInfo['directions'][$directionID]['running'] = $directionInfo['running'];
            
            // sort stops 
            usort($routeInfo['directions'][$directionID]['segments'], array(get_class(), 'sortDirectionSegments'));
        }
        self::dlog('routeInfo[\'directions\']: '.print_r($routeInfo['directions'], true), self::DLOG_STOP_GRAPH_SORT);
        
        $this->setUpcomingRouteStops($routeID, $routeInfo['directions'], $segmentTimeRange);
        
        $this->applyRouteInfoOverrides($routeID, $routeInfo);
        
        if ($routeInfo['splitByHeadsign']) {
            // Headsigns are named so sort them
            uasort($routeInfo['directions'], array(get_class(), 'sortDirections'));
        }
        
        // Do this last because it will confuse everything else!
        if ($this->viewRouteAsLoop($routeID)) {
            $routeInfo['directions'] = self::mergeDirections($routeInfo['directions']);
        }
        
        self::dlog('routeInfo: '.print_r($routeInfo, true), self::DLOG_STOP_GRAPH_SORT);
        
        return $routeInfo;
    }
    
    public static function mergeDirections($directions) {
        $names = array();
        $segments = array();
        $stops = array();
        
        foreach ($directions as $directionID => $directionInfo) {
            $names[] = $directionInfo['name'];
            $segments = array_merge($segments, $directionInfo['segments']);
            $stops = array_merge($stops, $directionInfo['stops']);
        }
        
        return array(
            self::LOOP_DIRECTION => array(
                'name'     => self::LOOP_DIRECTION_NAME,
                'segments' => $segments,
                'stops'    => $stops,
            ),
        );
    }
  
    public function getRoutes($time=null) {
        $routes = array();
        foreach ($this->routes as $routeID => $route) {
            $runningTimeRange = $this->getValidRouteRunningTimeRangeForTimestamp($routeID, $time);
            $segmentTimeRange = $this->getValidRouteSegmentTimeRangeForTimestamp($routeID, $time);
            
            $this->updatePredictionData($routeID);
            
            $inService = false; // Safety in case isRunning doesn't set this
            $isRunning = $route->isRunning($runningTimeRange, $inService);
            
            $routes[$routeID] = array(
                'name'         => $route->getName(),
                'description'  => $route->getDescription(),
                'color'        => $this->getRouteColor($routeID),
                'frequency'    => round($route->getServiceFrequency($segmentTimeRange) / 60),
                'agency'       => $route->getAgencyID(),
                'live'         => $isRunning ? $this->isLive() : false,
                'inService'    => $inService,
                'running'      => $isRunning,
                'view'         => $this->viewRouteInScheduleView($routeID) ? 'schedule' : 'list',
            );
            
            $this->applyRouteInfoOverrides($routeID, $routes[$routeID]);
        }
        
        uasort($routes, array(get_class(), 'sortRoutes'));
        
        return $routes;
    }
    
    protected function applyRouteInfoOverrides($routeID, &$routeInfo) {
        if (isset($this->overrides['route'])) {
            foreach ($this->overrides['route'] as $field => $overrides) {
                if (isset($overrides[$routeID])) {
                    $routeInfo[$field] = $overrides[$routeID];
                }
            }
        }
        if (isset($routeInfo['stops'], $this->overrides['stop'])) {
            foreach ($routeInfo['stops'] as $stopID => $stopInfo) {
                foreach ($this->overrides['stop'] as $field => $overrides) {
                    if (isset($overrides[$stopID], $stopInfo[$field])) {
                        $routeInfo['stops'][$stopID][$field] = $overrides[$stopID];
                    }
                }
            }
        }
    }
    
    protected function applyStopInfoOverrides($stopID, &$stopInfo) {
        if (isset($this->overrides['stop'])) {
            foreach ($this->overrides['stop'] as $field => $overrides) {
                if (isset($overrides[$stopID])) {
                    $stopInfo[$field] = $overrides[$stopID];
                }
            }
        }
        if (isset($stopInfo['routes'], $this->overrides['route'])) {
            foreach ($stopInfo['routes'] as $routeID => $routeInfo) {
                foreach ($this->overrides['route'] as $field => $overrides) {
                    if (isset($overrides[$routeID], $stopInfo[$field])) {
                        $stopInfo['routes'][$routeID][$field] = $overrides[$routeID];
                    }
                }
            }
        }
    }
    
    public static function isSameStop($stopID, $compareStopID) {
        if ($stopID == $compareStopID) {
            return true;
        }
        if ($stopID == $compareStopID.'_ar') {
            return true;
        }
        if ($stopID.'_ar' == $compareStopID) {
            return true;
        }
        return false;
    }
    
    public static function removeLastStop(&$stops) {
        end($stops);
        unset($stops[key($stops)]);
    }
    
    public static function removeFirstStop(&$stops) {
        reset($stops);
        unset($stops[key($stops)]);
    }
    
    public static function sortStops($a, $b) {
        if ($a["i"] == $b["i"]) { 
            return 0; 
        }
        return ($a["i"] < $b["i"]) ? -1 : 1;
    }
    
    public static function sortStopIs($type, $a, $b, $seenStopList=array()) {
        $stopInfo = self::$sortHelper[$a];
        foreach (self::$sortHelper[$a][$type] as $stopID) {
            if ($stopID == $b) {
                return true;
            } else if (!in_array($stopID, $seenStopList)) {
                $seenStopList[] = $stopID;
                return self::sortStopIs($type, $a, $stopID, $seenStopList);
            }
        }
        return false;
    }
    
    public static function sortByStopOrder($a, $b) {
        if ($a == $b) {
            return 0;
        }
        
        if (self::sortStopIs('before', $a, $b) || self::sortStopIs('after', $b, $a)) {
            return -1;
        } else if (self::sortStopIs('after', $a, $b) || self::sortStopIs('before', $b, $a)) {
            return 1;
        }
        Kurogo::log(LOG_WARNING, "Not enough information in trip stop orders to determine the relative order of stops $a and $b", 'transit');
        
        return 0;
    }

    protected function lookupStopOrder($agencyID, $routeID, $directionID, &$directionName) {
        if (!$this->stopOrders) {
            $config = ConfigFile::factory('transit-stoporder', 'site');
            $stopOrderConfigs = $config->getSectionVars(Config::EXPAND_VALUE);
            
            foreach ($stopOrderConfigs as $stopOrderConfig) {
                if (!isset($stopOrderConfig['route_id'])) { continue; }
                
                $stops = array();
                if (isset($stopOrderConfig['stop_ids'])) {
                    $stops = array_values($stopOrderConfig['stop_ids']);
                }
                
                $this->stopOrders[] = array(
                    'agencyID'      => $stopOrderConfig['agency_id'],
                    'routeID'       => $stopOrderConfig['route_id'],
                    'directionID'   => $stopOrderConfig['direction_id'],
                    'directionName' => $stopOrderConfig['direction_name'],
                    'stops'         => $stops,
                );
            }
        }
        
        foreach ($this->stopOrders as $stopOrder) {
            if ($stopOrder['agencyID'] == $agencyID && 
                    $stopOrder['routeID'] == $routeID && 
                    $stopOrder['directionID'] == $directionID) {
                $directionName = $stopOrder['directionName'];
                return $stopOrder['stops'];
            }
        }
        return array();
    }
    
    public static function sortRoutes($a, $b) {
        if ($a['running'] == $b['running']) {
            return strnatcmp($a['name'], $b['name']); // both offline or both running
            
        } else if ($a['running']) {
            return -1; // only $a running
            
        } else {
            return 1; // only $b running
        }
    }
    
    public static function sortDirections($a, $b) {
        if ($a['running'] == $b['running']) {
            return strnatcmp($a['name'], $b['name']); // both offline or both running
            
        } else if ($a['running']) {
            return -1; // only $a running
            
        } else {
            return 1; // only $b running
        }
    }
    
    protected static function sortDirectionSegments($a, $b) {
        for ($i = 0; $i < count($a['stops']); $i++) {
            if (isset($a['stops'][$i], $a['stops'][$i]['arrives'],
                                $b['stops'][$i], $b['stops'][$i]['arrives']) &&
                    $a['stops'][$i]['arrives'] && $b['stops'][$i]['arrives']) {
                // Found a stop where both $a and $b have stop times
                if ($a['stops'][$i]['arrives'] < $b['stops'][$i]['arrives']) {
                    return -1;
                } else if ($a['stops'][$i]['arrives'] > $b['stops'][$i]['arrives']) {
                    return 1;
                } else {
                    return 0;
                }
            }
        }
        
        self::dlog("Found two trips with no stop overlap", self::DLOG_STOP_GRAPH_SORT);
        
        // There are no stop overlaps between $a and $b, just order them by first stop time
        $aFirstStopTime = PHP_INT_MAX;
        $bFirstStopTime = PHP_INT_MAX;
        
        foreach ($a['stops'] as $stop) {
            if (isset($stop['arrives']) && $stop['arrives']) {
                $aFirstStopTime = $stop['arrives'];
                break;
            }
        }
        foreach ($b['stops'] as $stop) {
            if (isset($stop['arrives']) && $stop['arrives']) {
                $bFirstStopTime = $stop['arrives'];
                break;
            }
        }
        
        if ($aFirstStopTime < $bFirstStopTime) {
            return -1;
        } else if ($aFirstStopTime > $bFirstStopTime) {
            return 1;
        }
        
        return 0;
    }
    
    protected function getRouteDirections($route, $timestampRange) {
        $routeDirections = array();
        
        $routeID = $route->getID();
        
        foreach ($route->getDirections() as $direction) {
            $directionID = is_numeric($direction) ? "direction_{$direction}" : $direction;
            
            // Check the config file to see if we can get headsign or stop order information
            $segments = $route->getSegmentsForDirection($direction);
            
            if ($this->viewRouteSplitByHeadsign($routeID)) {
                // use the headsign as the direction id
                // note that we may end up with more than 2 directions
                foreach ($segments as $segment) {
                    $headsign = trim($segment->getName());
                    if (!$headsign) {
                        $headsign = $directionName;
                    }
                    if (!$headsign) {
                        $headsign = "Direction {$direction}";
                    }
                    
                    if (!isset($routeDirections[$headsign])) {
                        $directionName = $headsign;
                        $stopOrder = $this->lookupStopOrder($route->getAgencyID(), $routeID, $headsign, $directionName);
                        
                        $routeDirections[$headsign] = array(
                            'name'      => $directionName,
                            'segments'  => array(),
                            'stopOrder' => $stopOrder,
                        );
                    }
                    $routeDirections[$headsign]['segments'][] = $segment;
                }
                
            } else {
                $directionName = '';
                $stopOrder = $this->lookupStopOrder($route->getAgencyID(), $routeID, $direction, $directionName);
                if ($direction === self::LOOP_DIRECTION) {
                    $directionName = self::LOOP_DIRECTION_NAME;
                    
                } else if (!$directionName) {
                    foreach ($segments as $segment) {
                        $directionName = trim($segment->getName());
                        if ($directionName) {
                            break;
                        }
                    }
                    if (!$directionName) {
                        $directionName = "Direction {$direction}";
                    }
                }
                
                $routeDirections[$directionID] = array(
                    'name'      => $directionName,
                    'segments'  => $segments,
                    'stopOrder' => $stopOrder,
                );
            }
        }
        
        foreach ($routeDirections as $directionID => $directionInfo) {
            $routeDirections[$directionID]['running'] = false;
            foreach ($directionInfo['segments'] as $segment) {
                if ($segment->isRunning($timestampRange)) {
                    $routeDirections[$directionID]['running'] = true;
                    break;
                }
            }
        }
        return $routeDirections;
    }
    
    protected function getDirectionInfo($routeID, $directionName, $directionSegments, $directionStops, $timestampRange) {
        if (!$directionStops) {
            // No direction stop list provided, build with graph
            
            $segmentStopOrders = array();
            foreach ($directionSegments as $segment) {
                if (!$segment->getService()->isRunning($timestampRange)) {
                    continue;
                }
                
                $segmentStopOrder = array();
                foreach ($segment->getStops() as $stopIndex => $stopInfo) {
                    // skip stops with non-integer ids (things like 'skipped')
                    if (!ctype_digit(strval($stopInfo['i']))) { continue; }
                    
                    $segmentStopOrder[] = $stopInfo['stopID'];
                }
                $segmentStopOrders[] = $segmentStopOrder;
            }
            self::dlog(print_r($segmentStopOrders, true), self::DLOG_STOP_GRAPH_SORT);
            
            $directionStops = $this->topologicalSortStops($routeID, $segmentStopOrders);
            self::dlog('directionStops: '.print_r($directionStops, true), self::DLOG_STOP_GRAPH_SORT);
        }
        
        $stopOrder = array();
        foreach ($directionStops as $stopID) {
            $stopOrder[] = array(
                'id'      => $stopID,
                'arrives' => null,
            );
        }

        // initialize arrives field
        foreach ($stopOrder as $i => $stop) {
            $stopOrder[$i]['arrives'] = null;
        }
        
        $fullStopList = $stopOrder;
        foreach ($fullStopList as $i => $stopInfo) {
            $stop = $this->getStop($stopInfo['id']);
            if (!$stop) {
                Kurogo::log(LOG_WARNING, "Attempt to look up invalid stop {$stopInfo['id']}", 'transit');
                continue;
            }
            
            $fullStopList[$i]['i']           = $i;
            $fullStopList[$i]['name']        = $stop->getName();
            $fullStopList[$i]['coordinates'] = $stop->getCoordinates();
            $fullStopList[$i]['hasTiming']   = false;
            $fullStopList[$i]['upcoming']    = false;
            
            $this->applyStopInfoOverrides($stopInfo['id'], $fullStopList[$i]);
        }
        
        $segments = array();
        
        foreach ($directionSegments as $segment) {
            if (!$segment->isRunning($timestampRange)) {
                self::dlog("segment {$segment->getID()} ({$segment->getName()}) is not running", self::DLOG_STOP_GRAPH_SORT);
                continue;
            }
            
            $segmentInfo = array(
                'id'   => $segment->getID(),
                'name' => $segment->getName(),
                'stops' => $stopOrder,
            );
            
            // When a segment uses frequencies it corresponds to multiple vehicle trips
            // so we need to expand it into multiple segmentInfos -- one for each vehicle
            $segmentNeedsFrequencyExpansion = $segment->hasFrequencies() && $this->viewRouteInScheduleView($routeID);

            //self::dlog('segment->getStops(): '.print_r($segment->getStops(), true), self::DLOG_STOP_GRAPH_SORT);
            
            $remainingStopsIndex = 0;
            foreach ($segment->getStops() as $i => $stopInfo) {
                $arrivalTime = null;
                
                if (isset($stopInfo['predictions']) && $stopInfo['predictions']) {
                    $arrivalTime = reset($stopInfo['predictions']);
                } else if (isset($stopInfo['arrives']) && $stopInfo['arrives']) {
                    $arrivalTimes = $segment->getArrivalTimesForStop($stopInfo['stopID'], $timestampRange);
                    if ($arrivalTimes) {
                        $arrivalTime = reset($arrivalTimes);
                    }
                }
                
                for ($j = $remainingStopsIndex; $j < count($segmentInfo['stops']); $j++) {
                    if ($segmentInfo['stops'][$j]['id'] == $stopInfo['stopID']) {
                        $remainingStopsIndex = $j+1;
                        if (self::DLOG_STOP_ORDER) {
                            $segmentInfo['stops'][$j]['i'] = $stopInfo['i']; // useful for debugging stop sorting issues
                        }
                        $segmentInfo['stops'][$j]['arrives'] = $arrivalTime;
                        if ($segmentNeedsFrequencyExpansion && isset($stopInfo['arrives'])) {
                            // keep frequency arrival offset so we can generate the real times below
                            $segmentInfo['stops'][$j]['frequencyArrives'] = $stopInfo['arrives'];
                        }

                        // Augment full stop list with this arrival time
                        if ($arrivalTime) {
                            $oldArrivalTime = $fullStopList[$j]['arrives'];
                            
                            $newTimeIsValid = TransitTime::timestampIsValidForTimestampRange($arrivalTime, $timestampRange);
                            $oldTimeIsValid = $oldArrivalTime && 
                                              TransitTime::timestampIsValidForTimestampRange($oldArrivalTime, $timestampRange);
                            
                            if ($newTimeIsValid || !$oldTimeIsValid) {
                                $fullStopList[$j]['arrives'] = $arrivalTime;
                                $fullStopList[$j]['hasTiming'] = true;
                                
                                if (isset($stopInfo['predictions'])) {
                                    $fullStopList[$j]['predictions'] = $stopInfo['predictions'];
                                }
                                
                                if (self::DLOG_ARRIVAL_TIMES) {
                                    // Debugging arrival time calculations
                                    $offset = $arrivalTime - reset($timestampRange);
                                    $mins = floor($offset / 60);
                                    $secs = $offset - ($mins * 60);
                                    $prev = $oldArrivalTime ? strftime("%H:%M:%S", $oldArrivalTime) : 'not set ';
                                    self::dlog('Arrival time for stop '.str_pad($stopInfo['stopID'], 8).' is in '.str_pad($mins, 3, ' ', STR_PAD_LEFT).'m '.str_pad($secs, 2, ' ', STR_PAD_LEFT).'s (now '.strftime("%H:%M:%S", $arrivalTime).' / was '.$prev.') '.$this->stops[$stopInfo['stopID']]->getName(), self::DLOG_ARRIVAL_TIMES);
                                }
                            }
                        }
                        break;
                    }
                }
                if ($j == count($segmentInfo['stops'])) {
                    Kurogo::log(LOG_WARNING, "Unable to place stop {$stopInfo['stopID']} for direction '$directionName' at index {$stopInfo['i']}", 'transit');
                }
            }
            
            if ($segmentNeedsFrequencyExpansion && count($segmentInfo['stops'])) {
                // When a segment uses frequencies it corresponds to multiple vehicle trips
                // so we need to expand it into multiple segmentInfos -- one for each vehicle
                // but we still need the code above because it populates the arrival times in the full stop list
                // and expands our stops for us
                
                $validStartTimes = $segment->getValidFrequencyStartTimes($timestampRange);
                foreach ($validStartTimes as $frequencyIndex => $frequencyStartTT) {
                    $frequencySegmentInfo = $segmentInfo;
                    $frequencySegmentInfo['id'] .= "_{$frequencyIndex}";
                    
                    $hasValidStopTimes = false;
                    foreach ($frequencySegmentInfo['stops'] as $i => $stopInfo) {
                        if (isset($stopInfo['frequencyArrives'])) {
                            $arrivesTT = TransitTime::addTimes($stopInfo['frequencyArrives'], $frequencyStartTT);
                            $arrives = TransitTime::getTimestampOnDateOfTimestampRange($arrivesTT, $timestampRange);
                            $frequencySegmentInfo['stops'][$i]['arrives'] = $arrives;
                            $hasValidStopTimes = true;
                        } else {
                            unset($frequencySegmentInfo['stops'][$i]['arrives']);
                        }
                        unset($frequencySegmentInfo['stops'][$i]['frequencyArrives']);
                    }
                    if ($hasValidStopTimes) {
                        $segments[] = $frequencySegmentInfo;
                    }
                }
                
            } else {
                $segments[] = $segmentInfo;
            }
        }
        
        // Useful for debugging stop sorting issues. Very noisy output
        if (self::DLOG_STOP_ORDER) {
            foreach ($segments as $segmentInfo) {
                self::dlog("Trip {$segmentInfo['id']} ($directionName)", self::DLOG_STOP_ORDER);
                foreach ($segmentInfo['stops'] as $stop) {
                    self::dlog("\t\t".str_pad($stop['id'], 8).' => '.(isset($stop['i']) ? $stop['i'] : 'skipped'), self::DLOG_STOP_ORDER);
                    unset($stop['i']);
                }
            }
        }
        
        return array(
            'name'     => $directionName,
            'segments' => $segments,
            'stops'    => $fullStopList,
        );
    }
    
    protected function stopBeforeAndAfter($segmentStopOrders) {
        $before = array();
        $after = array();
        
        // Build up 2D arrays of stop-before-stop and stop-after-stop relationships
        // This gives is a directed graph which we can then sort
        foreach ($segmentStopOrders as $segmentStopOrder) {
            for ($i = 0; $i < count($segmentStopOrder); $i++) {
                // Make sure every stop exists in these arrays so we consume all stops
                if (!isset($before[$segmentStopOrder[$i]])) {
                    $before[$segmentStopOrder[$i]] = array();
                }
                if (!isset($after[$segmentStopOrder[$i]])) {
                    $after[$segmentStopOrder[$i]] = array();
                }

                if ($i > 0) {
                    $before[$segmentStopOrder[$i]][$segmentStopOrder[$i-1]] = true;
                }
                if ($i < (count($segmentStopOrder) - 1)) {
                    $after[$segmentStopOrder[$i]][$segmentStopOrder[$i+1]] = true;
                }
                
            }
        }
        
        return array($before, $after);
    }
    
    protected function topologicalSortStops($routeID, $segmentStopOrders) {
        $stopOrder = array();
        
        // Sort the directed graph, accounting for cycles
        // Cycles occur when a stop is visited more than once in a direction
        // or in difference places in the stop order at different times of day
        
        list($before, $after) = $this->stopBeforeAndAfter($segmentStopOrders);
        while ($after) {
            $best = null;
            $count = PHP_INT_MAX;
            
            // Find the best stop: the stop with fewest stops before it
            $afterStops = array_keys($after);
            foreach ($after as $stop => $afterStop) {
                $beforeStops = isset($before[$stop]) ? array_keys($before[$stop]) : array();
                if (!isset($count) || count($beforeStops) < $count) {
                    $best = $stop;
                    $count = count($beforeStops);
                    if ($count === 0) {
                        break; // first stop!
                    }
                }
            }
            if (!isset($best)) {
                // Fatal error
                $warning = "Failed to find best stop for route $routeID.  Aborting.";
                self::dlog($warning, self::DLOG_STOP_ORDER);
                Kurogo::log(LOG_WARNING, $warning, 'transit');
                break;
            }            

            if ($count > 0) {
                // Normal case for routes with cycles, just log debug message
                self::dlog("Stop order repeats stop $best", self::DLOG_STOP_ORDER);
            }
            
            // Place the stop
            $stopOrder[] = $best;
            self::dlog("Placed stop $best", self::DLOG_STOP_ORDER);
            
            // Remove the newly placed stop from the stop order
            $removedBest = false;
            foreach ($segmentStopOrders as $i => $segmentStopOrder) {
                if (reset($segmentStopOrder) == $best) {
                    array_shift($segmentStopOrders[$i]);
                    $removedBest = true;
                }
            }
            if (!$removedBest) {
                // This happens when the stop we picked isn't actually the first stop on any of the segments.
                // It usually means that the order cannot be determined from the segment stop orders.
                // Try to show something but warn that a configuration is needed to show the correct thing.
                $warning = "Stop $best not in order in any segment in route $routeID.  Please add stop order to transit-stoporders.ini";
                self::dlog($warning, self::DLOG_STOP_ORDER);
                Kurogo::log(LOG_WARNING, $warning, 'transit');
                
                foreach ($segmentStopOrders as $i => $segmentStopOrder) {
                    $firstLoc = array_search($best, $segmentStopOrder);
                    if ($firstLoc !== false) {
                        array_slice($segmentStopOrders[$i], $firstLoc, 1);
                    }
                }
            }

            list($before, $after) = $this->stopBeforeAndAfter($segmentStopOrders);
        }
        
        return $stopOrder;
    }
}

/**
  * Transit compacted time to reduce memory footprint
  * @package Transit
  */

class TransitTime
{   
    private static $localTimezone = null;
    private static $gmtTimezone = null;
    
    const HOUR_MULTIPLIER = 10000;
    const MINUTE_MULTIPLIER = 100;
    
    private static function getLocalTimezone() {
        if (!isset(self::$localTimezone)) {
            self::$localTimezone = Kurogo::siteTimezone();
        }
        return self::$localTimezone;
    }
  
    private static function getGMTTimezone() {
        if (!isset(self::$gmtTimezone)) {
            self::$gmtTimezone = new DateTimeZone('GMT');
        }
        return self::$gmtTimezone;
    }
  
    private static function getComponents($tt) {
        $hours = floor($tt/self::HOUR_MULTIPLIER);
        $minutes = floor(($tt - $hours*self::HOUR_MULTIPLIER)/self::MINUTE_MULTIPLIER); 
        $seconds = $tt - $minutes*self::MINUTE_MULTIPLIER - $hours*self::HOUR_MULTIPLIER;
        
        return array($hours, $minutes, $seconds);
    }
    
    private static function createFromComponents($hours, $minutes, $seconds) {
        if ($seconds < 0 || $seconds > 59) {
            $addMinutes = $seconds < 0 ? ceil($seconds/60) : floor($seconds/60);
            $minutes += $addMinutes;
            $seconds -= $addMinutes*60;
        }
        if ($minutes < 0 || $minutes > 59) {
            $addHours = $minutes < 0 ? ceil($minutes/60) : floor($minutes/60);
            $hours += $addHours;
            $minutes -= $addHours*60;
        }
        
        return $hours*self::HOUR_MULTIPLIER + $minutes*self::MINUTE_MULTIPLIER + $seconds;
    }
    
    public static function getLocalDatetimeFromTimestampRange($timestampRange) {
        $timestamp = reset($timestampRange);
        $datetime = new DateTime('@'.$timestamp, self::getGMTTimezone());
        $datetime->setTimeZone(self::getLocalTimezone());
        
        $hours = intval($datetime->format('G'));
        if ($hours < 5) {
            $datetime->modify('-1 day'); // before 5am is for the previous day
        }
        
        return $datetime;
    }
  
    public static function getCurrentTime() {
        return time();
    }
    
    public static function createFromString($timeString) {
        list($hours, $minutes, $seconds) = explode(':', $timeString);
        
        $hours = intval($hours);
        $minutes = intval($minutes);
        $seconds = intval($seconds);
        
        return self::createFromComponents($hours, $minutes, $seconds);
    }
    
    public static function createFromTimestamp($timestamp) {
        $datetime = new DateTime('@'.$timestamp, self::getGMTTimezone());
        $datetime->setTimeZone(self::getLocalTimezone());
        
        $hours = intval($datetime->format('G'));
        if ($hours < 5) {
            $hours += 24; // Before 5am is represented as hours+24 (eg 1am is 25:00:00)
        }
        $minutes = intval($datetime->format('i'));
        $seconds = intval($datetime->format('s'));
        
        return self::createFromComponents($hours, $minutes, $seconds);
    }
    
    public static function getString($tt) {
        list($hours, $minutes, $seconds) = self::getComponents($tt);
        
        return 
            str_pad($hours,   2, '0', STR_PAD_LEFT).':'.
            str_pad($minutes, 2, '0', STR_PAD_LEFT).':'.
            str_pad($seconds, 2, '0', STR_PAD_LEFT);
    }
    
    public static function getTimestampOnDateOfTimestampRange($tt, $timestampRange) {
        $date = self::getLocalDatetimeFromTimestampRange($timestampRange);
    
        list($hours, $minutes, $seconds) = explode(':', $date->format('G:i:s'));
        $dateTT = self::createFromComponents($hours, $minutes, $seconds);
      
        list($ttHours, $ttMinutes, $ttSeconds) = self::getComponents($tt);
    
        // Note: getLocalDatetimeFromTimestamp subtracts a day if it is before 5am
        // so it will end up being the same day if ttHours > 23
        if ($ttHours > 23) {
            $date->modify('+1 day');
        }
        
        $date->setTime($ttHours, $ttMinutes, $ttSeconds);
        
        return $date->format('U');
    }
    
    public static function compare($tt1, $tt2) {
        TransitDataModel::dlog("Comparing ".self::getString($tt1)." to ".self::getString($tt2), TransitDataModel::DLOG_TRANSIT_TIME);
        
        if ($tt1 == $tt2) {
            return 0;
        } else {
            return $tt1 < $tt2 ? -1 : 1;
        }
    }
    
    public static function addSecondsToTime($tt, $addSeconds) {
        list($hours, $minutes, $seconds) = self::getComponents($tt);
        return self::createFromComponents($hours, $minutes, $seconds+$addSeconds);
    }
    
    public static function addMinutesToTime(&$tt, $addMinutes) {
        list($hours, $minutes, $seconds) = self::getComponents($tt);
        return self::createFromComponents($hours, $minutes+$addMinutes, $seconds);
    }
    
    public static function addHoursToTime(&$tt, $addHours) {
        list($hours, $minutes, $seconds) = self::getComponents($tt);
        return self::createFromComponents($hours+$addHours, $minutes, $seconds);
    }
    
    public static function addTimes($tt1, $tt2) {
        list($hours1, $minutes1, $seconds1) = self::getComponents($tt1);
        list($hours2, $minutes2, $seconds2) = self::getComponents($tt2);
        return self::createFromComponents($hours1+$hours2, $minutes1+$minutes2, $seconds1+$seconds2);
    }

    public static function getDifferenceInSeconds($fromTT, $toTT) {
        $intervalTT = $toTT;
        list($hours,   $minutes,   $seconds)    = self::getComponents($fromTT);
        list($toHours, $toMinutes, $toSeconds) = self::getComponents($toTT);

        return (($toHours-$hours) * 60 + ($toMinutes - $minutes)) * 60 + ($toSeconds - $seconds);
    }
    
    public static function timeIsValidForTimestampRange($tt, $timestampRange) {
        $startTT = TransitTime::createFromTimestamp($timestampRange[0]);
        $endTT = TransitTime::createFromTimestamp($timestampRange[1]);
        
        $inRange = TransitTime::compare($tt, $startTT) >= 0 && TransitTime::compare($tt, $endTT) <= 0;
        
        TransitDataModel::dlog(TransitTime::getString($tt).' is '.($inRange ? '' : 'not ').'in range '.TransitTime::getString($startTT).' - '.TransitTime::getString($endTT), TransitDataModel::DLOG_TRANSIT_TIME);
        return $inRange;
    }
    
    public static function timesRangeIsValidForTimestampRange($fromTT, $toTT, $timestampRange) {
        $startTT = TransitTime::createFromTimestamp($timestampRange[0]);
        $endTT = TransitTime::createFromTimestamp($timestampRange[1]);
        
        $endBeforeFrom = TransitTime::compare($endTT, $fromTT) < 0; // timestamp before range
        $toBeforeStart = TransitTime::compare($toTT, $startTT) < 0; // range before timestamp
        $inRange = !$endBeforeFrom && !$toBeforeStart;
        
        TransitDataModel::dlog(TransitTime::getString($startTT).' - '.TransitTime::getString($endTT)." is ".($inRange ? '' : 'not ')."in range ".TransitTime::getString($fromTT).' - '.TransitTime::getString($toTT), TransitDataModel::DLOG_TRANSIT_TIME);
        return $inRange;
    }
    
    public static function timestampIsValidForTimestampRange($timestamp, $timestampRange) {
        return $timestamp >= reset($timestampRange) && $timestamp <= end($timestampRange);
    }
}

/**
  * Transit Route Object
  * @package Transit
  */

class TransitRoute
{
    protected $id = null;
    protected $name = null;
    protected $description = null;
    protected $agencyID = null;
    protected $directions = array();
    
    function __construct($id, $agencyID, $name, $description) {
        $this->id = $id;
        $this->name = $name;
        $this->description = $description;
        $this->agencyID = $agencyID;
        $this->paths = array();
    }
    
    public function getID() {
        return $this->id;
    }
      
    public function getName() {
        return $this->name;
    }
      
    public function getDescription() {
        return $this->description;
    }
      
    public function getAgencyID() {
        return $this->agencyID;
    }
      
    public function addSegment(&$segment) {
        $direction = $segment->getDirection();
      
        if (!isset($this->directions[$direction])) {
            $this->directions[$direction] = array(
                'segments' => array(),
            );
        }
        
        $segmentID = $segment->getID();
        if (isset($this->directions[$direction]['segments'][$segmentID])) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): Duplicate segment '$segmentID' for route '{$this->name}'", 'transit');
        }
        
        $this->directions[$direction]['segments'][$segmentID] = $segment;
    }
    
    public function getDirections() {
        return array_keys($this->directions);
    }
    
    public function getDirection($id) {
        if (!isset($this->directions[$id])) {
            Kurogo::log(LOG_WARNING, __FUNCTION__."(): No such direction '$id'", 'transit');
            return false;
        }
        return $this->directions[$id];
    }
    
    public function getSegmentsForDirection($direction) {
        $direction = $this->getDirection($direction);
        return $direction['segments'];
    }

    public function setStopPredictions($directionID, $stopID, $predictions) {
        $direction = $this->getDirection($directionID);
        if ($direction && isset($direction['segments'])) {
            foreach ($direction['segments'] as $segment) {
                $segment->setStopPredictions($stopID, $predictions);
            }
        }
    }
    
    public function getStops() {
        $stops = array();
        foreach ($this->directions as $directionID => $direction) {
            foreach ($direction['segments'] as $segment) {
                foreach ($segment->getStops() as $stopInfo) {
                    $stops[] = $stopInfo;
                }
            }
        }
        return $stops;
    }
    
    public function hasStop($stopID) {
        foreach ($this->directions as $directionID => $direction) {
            foreach ($direction['segments'] as $segment) {
                foreach ($segment->getStops() as $stopInfo) {
                    if ($stopInfo['stopID'] == $stopID) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    public function isRunning($timestampRange, &$inService=null) {
        $inService = false;
        
        foreach ($this->directions as $directionID => $direction) {
            foreach ($direction['segments'] as $segment) {
                TransitDataModel::dlog("    Looking at segment {$segment->getName()}", TransitDataModel::DLOG_IS_RUNNING);
                
                if ($segment->getService()->isRunning($timestampRange)) {
                    $inService = true;
                    TransitDataModel::dlog("Route {$this->id} ({$this->name}) is in service", TransitDataModel::DLOG_IS_RUNNING);
                    
                    if ($segment->isRunning($timestampRange)) {
                        TransitDataModel::dlog("Route {$this->id} ({$this->name}) is running", TransitDataModel::DLOG_IS_RUNNING);
                        return true;
                    }
                }
            }
        }
        
        TransitDataModel::dlog("Route {$this->id} ({$this->name}) is not running", TransitDataModel::DLOG_IS_RUNNING);
        return false;
    }
    
    protected function segmentsUseFrequencies() {
        foreach ($this->directions as $direction) {
            foreach ($direction['segments'] as $segment) {
                return $segment->hasFrequencies();
            }
        }
        return false;
    }
    
    protected function getFirstStopIDAndDirection() {
        foreach ($this->directions as $directionID => $direction) {
            foreach ($direction['segments'] as $segment) {
                foreach ($segment->getStops() as $stopInfo) {
                    return array($stopInfo['stopID'], $directionID);
                }
            }
        }
        return array(false, false);
    }
    
    public function getServiceFrequency($timestampRange) {
        $upcomingSegmentPadding = end($timestampRange) - reset($timestampRange);
        
        // Time between shuttles at the same stop
        $frequency = 0;
        
        if ($this->segmentsUseFrequencies()) {
            foreach ($this->directions as $direction) {
                foreach ($direction['segments'] as $segment) {
                    if ($segment->isRunning($timestampRange)) {
                        $frequency = $segment->getFrequency($timestampRange);
                        if ($frequency > 0) { break; }
                    }
                    if ($frequency > 0) { break; }
                }
                if ($frequency > 0) { break; }
            }
        } else {
            // grab the first stop and check how often vehicles arrive at it
            list($stopID, $directionID) = $this->getFirstStopIDAndDirection();
                  
            if ($stopID) {
                $arrivalTimes = array();
                
                foreach ($this->directions[$directionID]['segments'] as $segment) {
                    if ($segment->getService()->isRunning($timestampRange)) {
                        $segmentArrivalTimes = $segment->getArrivalTimesForStop($stopID, $timestampRange);
                        $arrivalTimes = array_merge($arrivalTimes, $segmentArrivalTimes);
                    }
                }
                $arrivalTimes = array_unique($arrivalTimes);
                sort($arrivalTimes);
              
                for ($i = 0; $i < count($arrivalTimes); $i++) {
                    if (TransitTime::timestampIsValidForTimestampRange($arrivalTimes[$i], $timestampRange)) {
                        if (isset($arrivalTimes[$i+1])) {
                            $frequency = $arrivalTimes[$i+1] - $arrivalTimes[$i];
                        } else if (isset($arrivalTimes[$i-1])) {
                            $frequency = $arrivalTimes[$i] - $arrivalTimes[$i-1];
                        }
                    }
                    if ($frequency > 0 && $frequency < $upcomingSegmentPadding) { break; }
                }
            }
            if ($frequency == 0) { $frequency = 60*60; } // default to 1 hour
        }
        return $frequency;
    }
    
    public function addPath($path) {
        $this->paths[] = $path;
    }
    
    public function getPaths() {
        $paths = array();
        foreach ($this->paths as $path) {
            $paths[$path->getID()] = $path->getPoints();
        }
        return $paths;
    }
}

/**
  * Transit class to track dates when route runs
  * @package Transit
  */

class TransitService
{
    protected $id = null;
    protected $dateRanges = array();
    protected $exceptions = array();
    protected $additions = array();
    
    protected $alwaysRunning = false;
    
    function __construct($id, $alwaysRunning=false) {
        $this->id = $id;
        $this->alwaysRunning = $alwaysRunning;
    }
    
    public function getID() {
        return $this->id;
    }
    public function addDateRange($firstDate, $lastDate, $weekdays) {
        $this->dateRanges[] = array(
            'first'    => intval($firstDate),
            'last'     => intval($lastDate),
            'weekdays' => $weekdays,
        );
    }
    
    public function addExceptionDate($date) {
        $this->exceptions[] = intval($date);
    }
    
    public function addAdditionalDate($date) {
        $this->additions[] = intval($date);    
    }
    
    public function isRunning($timestampRange) {
        if ($this->alwaysRunning) { return true; }
      
        $datetime = TransitTime::getLocalDatetimeFromTimestampRange($timestampRange);
        
        $date = intval($datetime->format('Ymd'));
        $dayOfWeek = $datetime->format('l');
        
        if (count($this->dateRanges)) {
            $insideValidDateRange = false;
            foreach ($this->dateRanges as $dateRange) {
                $week = $dateRange['weekdays'];
              
                if ($date >= $dateRange['first'] && $date <= $dateRange['last'] && $week[strtolower($dayOfWeek)]) {
                    $insideValidDateRange = true;
                    break;
                }
            }
        } else {
            // no date ranges means always valid
            $insideValidDateRange = true;
        }
        
        $isException  = in_array($date, $this->exceptions);
        $isAddition   = in_array($date, $this->additions);
        
        TransitDataModel::dlog("service $service is ".($isAddition || ($inValidDateRange && !$isException) ? '' : 'not ').'running', TransitDataModel::DLOG_IS_RUNNING);
        
        return $isAddition || ($insideValidDateRange && !$isException);
    }
}

/**
  * Transit class to described sets of stops which are part of a route
  * @package Transit
  */

class TransitSegment
{
    protected $id = null;
    protected $name = null;
    protected $service = null;
    protected $direction = null;
    protected $stopsSorted = false;
    protected $stops = array();
    protected $frequencies = null;
    protected $frequencyStartTimes = array();
    
    protected $hasPredictions = false;
    
    function __construct($id, $name, $service, $direction) {
        $this->id = $id;
        $this->name = $name;
        $this->service = $service;
        $this->direction = $direction;
    }
    
    public function getID() {
        return $this->id;
    }
    
    public function getName() {
        return $this->direction === TransitDataModel::LOOP_DIRECTION ? 
            TransitDataModel::LOOP_DIRECTION_NAME : $this->name;
    }
  
    public function getDirection() {
        return $this->direction;
    }
  
    public function getService() {
        return $this->service;
    }
  
    public function addFrequency($firstTT, $lastTT, $frequency) {
        if (!isset($this->frequencies)) {
            $this->frequencies = array();
        }
            
        $this->frequencies[] = array(
            'start'     => $firstTT,
            'end'       => $lastTT,
            'frequency' => intval($frequency),
        );

        $currentTT = $firstTT;
        while (TransitTime::compare($currentTT, $lastTT) <= 0) {
            $this->frequencyStartTimes[] = $currentTT;
            
            $currentTT = TransitTime::addSecondsToTime($currentTT, intval($frequency));
        }
        sort($this->frequencyStartTimes);
    }
    
    public function hasFrequencies() {
        return isset($this->frequencies);
    }
    
    public function getFrequency($timestampRange) {
        $frequency = false;
        
        if (isset($this->frequencies)) {
            foreach ($this->frequencies as $index => $frequencyInfo) {
                if (TransitTime::timesRangeIsValidForTimestampRange($frequencyInfo['start'], $frequencyInfo['end'], $timestampRange)) {
                    $frequency = $frequencyInfo['frequency'];
                    break;
                } else if (!$frequency) {
                    $frequency = $frequencyInfo['frequency'];
                }
            }
        }
        return $frequency;
    }
    
    public function getFrequencyStartTimes() {
        return $this->frequencyStartTimes;
    }
    
    public function getValidFrequencyStartTimes($timestampRange) {
        $frequencyStartTimes = array();
        
        $firstStop = reset($this->stops);
        $lastStop = end($this->stops);
        foreach ($this->frequencyStartTimes as $frequencyStartTime) {
            $startTT = TransitTime::addTimes($firstStop['arrives'], $frequencyStartTime);
            $endTT = TransitTime::addTimes($lastStop['arrives'], $frequencyStartTime);
            
            if (TransitTime::timesRangeIsValidForTimestampRange($startTT, $endTT, $timestampRange)) {
                $frequencyStartTimes[] = $frequencyStartTime;
            }
        }
        return $frequencyStartTimes;
    }
    
    public function addStop($stopID, $sequenceNumber) {
        $this->stops[] = array(
            'stopID'    => $stopID,
            'i'         => intval($sequenceNumber),
            'hasTiming' => false,
        );
        $this->stopsSorted = false;
    }
    
    protected function getIndexForStop($stopID) { 
        foreach ($this->stops as $index => $stop) {
            if ($stopID == $stop['stopID']) {
                return $index;
            }
        }
        return false;
    }
  
    public function setStopPredictions($stopID, $predictions) {
        $index = $this->getIndexForStop($stopID);
        if ($index !== false) {
            if (!$this->hasPredictions && count($predictions)) {
                $this->hasPredictions = true;
            }
            $this->stops[$index]['predictions'] = $predictions;
            $this->stops[$index]['hasTiming'] = count($predictions) > 0;
        }
    }
    
    protected function sortStopsIfNeeded() {
        if (!$this->stopsSorted) {
            usort($this->stops, array('TransitDataModel', 'sortStops'));
            $this->stopsSorted = true;
        }
    }
    
    public function getStops() {
        $this->sortStopsIfNeeded();
        return $this->stops;
    }
    
    public function hasPredictions() {
        return $this->hasPredictions;
    }
    
    public function isRunning($timestampRange) {
        $this->sortStopsIfNeeded();
    
        if ($this->hasPredictions) {
            foreach ($this->stops as $index => $stop) {
                if (isset($stop['predictions']) && is_array($stop['predictions'])) {
                    foreach ($stop['predictions'] as $prediction) {
                        if (TransitTime::timestampIsValidForTimestampRange($prediction, $timestampRange)) {
                            return true; // live service with valid prediction
                        }
                    }
                }
            }
        }
        
        if ($this->service->isRunning($timestampRange)) {
            if (isset($this->frequencies)) {
                foreach ($this->frequencies as $index => $frequencyInfo) {
                    if (TransitTime::timesRangeIsValidForTimestampRange($frequencyInfo['start'], $frequencyInfo['end'], $timestampRange)) {
                        return true;
                    }
                }
            } else {
                $firstStop = reset($this->stops);
                $lastStop  = end($this->stops);
                
                if (isset($firstStop['arrives'], $lastStop['departs'])) {
                    if (TransitTime::timesRangeIsValidForTimestampRange($firstStop['arrives'], $lastStop['departs'], $timestampRange)) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
    
    public function getArrivalTimesForStop($stopID, $timestampRange) {
        $arrivalTimes = array(); 
        $index = 0;
        if (isset($stopID)) {
            $index = $this->getIndexForStop($stopID);
        }

        if ($index !== false && isset($this->stops[$index])) {
            $stop = $this->stops[$index];
            
            if (isset($stop['predictions'])) {
                foreach ($stop['predictions'] as $prediction) {
                    if (TransitTime::timestampIsValidForTimestampRange($prediction, $timestampRange)) {
                        $arrivalTimes[] = $prediction;
                    }
                }
            }
            
            if (!count($arrivalTimes) && isset($stop['arrives'])) {
                if (count($this->frequencyStartTimes)) {
                    // see if we get any valid ones.  If we do, use those
                    foreach ($this->frequencyStartTimes as $startTT) {
                        $testTT = TransitTime::addTimes($stop['arrives'], $startTT);
                        if (TransitTime::timeIsValidForTimestampRange($testTT, $timestampRange)) {
                            $arrivalTimes[] = TransitTime::getTimestampOnDateOfTimestampRange($testTT, $timestampRange);
                        }
                    }
                    
                    if (!$arrivalTimes) {
                        // no valid start times, just start from the first one and go out the range difference
                        $firstStartTT = reset($this->frequencyStartTimes);
                        $firstArrivalTT = TransitTime::addTimes($stop['arrives'], $firstStartTT);
                        $firstArrivalTimestamp = TransitTime::getTimestampOnDateOfTimestampRange($firstArrivalTT, $timestampRange);
                        $timestampRangeDifference = end($timestampRange) - reset($timestampRange);
                        $alternateTimestampRange = array($firstArrivalTimestamp, $firstArrivalTimestamp + $timestampRangeDifference);
                        
                        foreach ($this->frequencyStartTimes as $startTT) {
                            $testTT = TransitTime::addTimes($stop['arrives'], $startTT);
                            if (TransitTime::timeIsValidForTimestampRange($testTT, $alternateTimestampRange)) {
                                $arrivalTimes[] = TransitTime::getTimestampOnDateOfTimestampRange($testTT, $alternateTimestampRange);
                            }
                        }
                    }
                } else {
                    $arrivalTimes[] = TransitTime::getTimestampOnDateOfTimestampRange($stop['arrives'], $timestampRange);
                }
            }
        }
        return $arrivalTimes;
    }
}

/**
  * Transit class to describe a stop
  * @package Transit
  */

class TransitStop
{
    protected $id = null;
    protected $name = null;
    protected $description = null;
    protected $latitude = null;
    protected $longitude = null;
    
    function __construct($id, $name, $description, $latitude, $longitude) {
        $this->id = $id;
        $this->name = $name;
        $this->description = $description;
        $this->latitude = floatVal($latitude);
        $this->longitude = floatVal($longitude);
    }
    
    public function getID() {
        return $this->id;
    }
    
    public function getName() {
        return $this->name;
    }
    
    public function getDescription() {
        return $this->description;
    }
    
    public function getCoordinates() {
        return array(
          'lat' => $this->latitude, 
          'lon' => $this->longitude,
        );
    }
}


/**
  * Transit class to describe a path
  * @package Transit
  */

class TransitPath
{
    protected $id = null;
    protected $points = array();
    
    function __construct($id, $points) {
      $this->id = $id;
      
      $pathPoints = array();
      foreach ($points as &$point) {
          if (is_array($point) && count($point) == 2) {
              $pathPoints[] = array(
                  'lat' => floatVal(reset($point)),
                  'lon' => floatVal(end($point)),
              );
          }
      }
      $this->points = $pathPoints;
    }
    
    public function getID() {
        return $this->id;
    }
    
    public function getPoints() {
        return $this->points;
    }
}
